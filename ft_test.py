import os
import torch
from transformers import (
    AutoModelForCausalLM,
    AutoTokenizer,
)
from peft import PeftModel

new_model = "llama-2-7b-structured-jpg-hex-40"
model = AutoModelForCausalLM.from_pretrained(
    "meta-llama/Llama-2-7b-chat-hf",
    torch_dtype=torch.bfloat16,
    device_map="auto",
    trust_remote_code=True,
)
model = PeftModel.from_pretrained(model, new_model)
model = model.merge_and_unload()

tokenizer = AutoTokenizer.from_pretrained("./" + new_model)

prompts = [
    "Generate a JPG example in hex format. Make sure the example is complete and valid. Only return the JPG example, no other words. Here is the text description you can refer A JPG image is represented as a sequence of segments where each segment begins with a marker. Each marker starts with 0xFF byte followed by marker flag to represent the type of marker. The payload followed by marker is different as per marker type. Common JPEG marker types are as listed below:Short Name Bytes	Payload	Name Comments```\n```SOI	0xFF, 0xD8 none Start of Image```\n ```S0F0 0xFF, 0xC0	variable size Start of Frame``` \n```S0F2 0xFF, 0xC2	variable size Start fo Frame```\n```DHT	0xFF, 0xC4	variable size Define Huffman Tables```\n```DQT	0xFF, 0xDB	variable size Define Quantization Table(s)```\n```DRI	0xFF, 0xDD	4 bytes	Define Restart Interval```\n```SOS	0xFF, 0xDA	variable size	Start Of Scan```\n```RSTn 0xFF, 0xD//n//(//n//#0..7) none Restart```\n```APPn 0xFF, 0xE//n// variable size Application specific```\n```COM	0xFF, 0xFE variable size Comment```\n```EOI	0xFF, 0xD9	none End Of Image```\n```Within the entropy-coded data, after any 0xFF byte, a 0x00 byte is inserted by the encoder before the next byte, so that there does not appear to be a marker where none is intended, preventing framing errors. Decoders must skip this 0x00 byte. This technique, called byte stuffing (see JPEG specification section F.1.2.3), is only applied to the entropy-coded data, not to marker payload data. Note however that entropy-coded data has a few markers of its own; specifically the Reset markers (0xD0 through 0xD7), which are used to isolate independent chunks of entropy-coded data to allow parallel decoding, and encoders are free to insert these Reset markers at regular intervals (although not all encoders do this).",
    "Generate a JPG example in hex format. Make sure the example is complete and valid. Only return the JPG example, no other words. Here is the text description you can refer A JPG image is represented as a sequence of segments where each segment begins with a marker. Each marker starts with 0xFF byte followed by marker flag to represent the type of marker. The payload followed by marker is different as per marker type. Common JPEG marker types are as listed below:Short Name Bytes	Payload	Name Comments```\n```SOI	0xFF, 0xD8 none Start of Image```\n ```S0F0 0xFF, 0xC0	variable size Start of Frame``` \n```S0F2 0xFF, 0xC2	variable size Start fo Frame```\n```DHT	0xFF, 0xC4	variable size Define Huffman Tables```\n```DQT	0xFF, 0xDB	variable size Define Quantization Table(s)```\n```DRI	0xFF, 0xDD	4 bytes	Define Restart Interval```\n```SOS	0xFF, 0xDA	variable size	Start Of Scan```\n```RSTn 0xFF, 0xD//n//(//n//#0..7) none Restart```\n```APPn 0xFF, 0xE//n// variable size Application specific```\n```COM	0xFF, 0xFE variable size Comment```\n```EOI	0xFF, 0xD9	none End Of Image```\n```Within the entropy-coded data, after any 0xFF byte, a 0x00 byte is inserted by the encoder before the next byte, so that there does not appear to be a marker where none is intended, preventing framing errors. Decoders must skip this 0x00 byte. This technique, called byte stuffing (see JPEG specification section F.1.2.3), is only applied to the entropy-coded data, not to marker payload data. Note however that entropy-coded data has a few markers of its own; specifically the Reset markers (0xD0 through 0xD7), which are used to isolate independent chunks of entropy-coded data to allow parallel decoding, and encoders are free to insert these Reset markers at regular intervals (although not all encoders do this).",
    "Generate a JPG example in hex format. Make sure the example is complete and valid. Only return the JPG example, no other words. Here is the text description you can refer A JPG image is represented as a sequence of segments where each segment begins with a marker. Each marker starts with 0xFF byte followed by marker flag to represent the type of marker. The payload followed by marker is different as per marker type. Common JPEG marker types are as listed below:Short Name Bytes	Payload	Name Comments```\n```SOI	0xFF, 0xD8 none Start of Image```\n ```S0F0 0xFF, 0xC0	variable size Start of Frame``` \n```S0F2 0xFF, 0xC2	variable size Start fo Frame```\n```DHT	0xFF, 0xC4	variable size Define Huffman Tables```\n```DQT	0xFF, 0xDB	variable size Define Quantization Table(s)```\n```DRI	0xFF, 0xDD	4 bytes	Define Restart Interval```\n```SOS	0xFF, 0xDA	variable size	Start Of Scan```\n```RSTn 0xFF, 0xD//n//(//n//#0..7) none Restart```\n```APPn 0xFF, 0xE//n// variable size Application specific```\n```COM	0xFF, 0xFE variable size Comment```\n```EOI	0xFF, 0xD9	none End Of Image```\n```Within the entropy-coded data, after any 0xFF byte, a 0x00 byte is inserted by the encoder before the next byte, so that there does not appear to be a marker where none is intended, preventing framing errors. Decoders must skip this 0x00 byte. This technique, called byte stuffing (see JPEG specification section F.1.2.3), is only applied to the entropy-coded data, not to marker payload data. Note however that entropy-coded data has a few markers of its own; specifically the Reset markers (0xD0 through 0xD7), which are used to isolate independent chunks of entropy-coded data to allow parallel decoding, and encoders are free to insert these Reset markers at regular intervals (although not all encoders do this).",
    "Generate a JPG example in hex format. Make sure the example is complete and valid. Only return the JPG example, no other words. Here is the text description you can refer A JPG image is represented as a sequence of segments where each segment begins with a marker. Each marker starts with 0xFF byte followed by marker flag to represent the type of marker. The payload followed by marker is different as per marker type. Common JPEG marker types are as listed below:Short Name Bytes	Payload	Name Comments```\n```SOI	0xFF, 0xD8 none Start of Image```\n ```S0F0 0xFF, 0xC0	variable size Start of Frame``` \n```S0F2 0xFF, 0xC2	variable size Start fo Frame```\n```DHT	0xFF, 0xC4	variable size Define Huffman Tables```\n```DQT	0xFF, 0xDB	variable size Define Quantization Table(s)```\n```DRI	0xFF, 0xDD	4 bytes	Define Restart Interval```\n```SOS	0xFF, 0xDA	variable size	Start Of Scan```\n```RSTn 0xFF, 0xD//n//(//n//#0..7) none Restart```\n```APPn 0xFF, 0xE//n// variable size Application specific```\n```COM	0xFF, 0xFE variable size Comment```\n```EOI	0xFF, 0xD9	none End Of Image```\n```Within the entropy-coded data, after any 0xFF byte, a 0x00 byte is inserted by the encoder before the next byte, so that there does not appear to be a marker where none is intended, preventing framing errors. Decoders must skip this 0x00 byte. This technique, called byte stuffing (see JPEG specification section F.1.2.3), is only applied to the entropy-coded data, not to marker payload data. Note however that entropy-coded data has a few markers of its own; specifically the Reset markers (0xD0 through 0xD7), which are used to isolate independent chunks of entropy-coded data to allow parallel decoding, and encoders are free to insert these Reset markers at regular intervals (although not all encoders do this).",
    "Generate a JPG example in hex format. Make sure the example is complete and valid. Only return the JPG example, no other words. Here is the text description you can refer A JPG image is represented as a sequence of segments where each segment begins with a marker. Each marker starts with 0xFF byte followed by marker flag to represent the type of marker. The payload followed by marker is different as per marker type. Common JPEG marker types are as listed below:Short Name Bytes	Payload	Name Comments```\n```SOI	0xFF, 0xD8 none Start of Image```\n ```S0F0 0xFF, 0xC0	variable size Start of Frame``` \n```S0F2 0xFF, 0xC2	variable size Start fo Frame```\n```DHT	0xFF, 0xC4	variable size Define Huffman Tables```\n```DQT	0xFF, 0xDB	variable size Define Quantization Table(s)```\n```DRI	0xFF, 0xDD	4 bytes	Define Restart Interval```\n```SOS	0xFF, 0xDA	variable size	Start Of Scan```\n```RSTn 0xFF, 0xD//n//(//n//#0..7) none Restart```\n```APPn 0xFF, 0xE//n// variable size Application specific```\n```COM	0xFF, 0xFE variable size Comment```\n```EOI	0xFF, 0xD9	none End Of Image```\n```Within the entropy-coded data, after any 0xFF byte, a 0x00 byte is inserted by the encoder before the next byte, so that there does not appear to be a marker where none is intended, preventing framing errors. Decoders must skip this 0x00 byte. This technique, called byte stuffing (see JPEG specification section F.1.2.3), is only applied to the entropy-coded data, not to marker payload data. Note however that entropy-coded data has a few markers of its own; specifically the Reset markers (0xD0 through 0xD7), which are used to isolate independent chunks of entropy-coded data to allow parallel decoding, and encoders are free to insert these Reset markers at regular intervals (although not all encoders do this).",
]
for prompt in prompts:
    inputs = tokenizer(prompt, return_tensors="pt")

    input_ids = inputs.input_ids.to("cuda")
    # Generate
    generate_ids = model.generate(
        input_ids,
        max_length=2048
        # ,
        # num_beams=5,
        # no_repeat_ngram_size=2,
        # num_return_sequences=5,
        # early_stopping=True,
    )
    ans = tokenizer.batch_decode(
        generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False
    )[0]
    print("################START#HERE################")
    print(ans)
    print("@@@@@@@@@@@@@@@@END@HERE@@@@@@@@@@@@@@@@")
